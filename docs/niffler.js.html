<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: niffler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: niffler.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/// &lt;reference types="node" />
"use strict";
/**
 * Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value. The
 * standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/).
 */
var Arithmetic;
(function (Arithmetic) {
    /**
     * The addition operator produces the sum of numeric operands or string concatenation.
     * Operator: x + y
     *
     * @param {*} operand1
     * @param {*} operand2
     * @returns {*}
     */
    function add(operand1, operand2) {
        return operand1 + operand2;
    }
    Arithmetic.add = add;
    /**
     * @alias of add
     */
    Arithmetic.concatenate = add;
    /**
     * The subtraction operator subtracts the two operands, producing their difference.
     * Operator: x - y
     *
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function subtract(operand1, operand2) {
        return operand1 - operand2;
    }
    Arithmetic.subtract = subtract;
    /**
     * The multiplication operator produces the product of the operands.
     * Operator: x * y
     *
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function multiply(operand1, operand2) {
        return operand1 * operand2;
    }
    Arithmetic.multiply = multiply;
    /**
     * The division operator produces the quotient of its operands where the left operand is the dividend and the right operand is the
     * divisor.
     * Operator: x / y
     *
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function divide(operand1, operand2) {
        return operand1 / operand2;
    }
    Arithmetic.divide = divide;
    /**
     * The remainder operator returns the remainder left over when one operand is divided by a second operand. It always takes the sign of
     * the dividend, not the divisor. It uses a built-in modulo function to produce the result, which is the integer remainder of dividing
     * var1 by var2 — for example — var1 modulo var2.
     * Operator: var1 % var2
     *
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function modulous(operand1, operand2) {
        return operand1 % operand2;
    }
    Arithmetic.modulous = modulous;
    /**
     * @alias of modulous
     */
    Arithmetic.remainder = modulous;
    if (parseFloat(process.versions.node) >= 7.2) {
        /**
         * The exponentiation operator returns the result of raising first operand to the power second operand. that is, var1 raised to the
         * power var2, in the preceding statement, where var1 and var2 are variables. Exponentiation operator is right associative.
         * a ** b ** c is equal to a ** (b ** c).
         * In most languages like PHP and Python and others that have an exponentiation operator (typically ^ or **), the exponentiation
         * operator is defined to have a higher precedence than unary operators such as unary + and unary -, but there are a few exceptions.
         * For example, in Bash the ** operator is defined to have a lower precedence than unary operators. In JavaScript, it is impossible to
         * write an ambiguous exponentiation expression, i.e. you cannot put a unary operator (+/-/~/!/delete/void/typeof) immediately before
         * the base number.
         * Operator: var1 ** var2
         *
         * @param {number} operand1
         * @param {number} operand2
         * @returns {number}
         */
        Arithmetic.exponentiation = function (operand1, operand2) {
            return Math.pow((operand1), (operand2));
        };
    }
    /**
     * Increment (++)
     * The increment operator increments (adds one to) its operand and returns a value.
     */
    /**
     * If used prefix with operator before operand (for example, ++x), then it returns the value after incrementing.
     * Operator: ++x
     *
     * @export
     * @param {number} operand
     * @returns {number}
     */
    function preIncrement(operand) {
        return ++(operand);
    }
    Arithmetic.preIncrement = preIncrement;
    /**
     * If used postfix, with operator after operand (for example, x++), then it returns the value before incrementing.
     * Operator: x++
     *
     * @param {number} operand
     * @returns {number}
     */
    function postIncrement(operand) {
        return (operand)++;
    }
    Arithmetic.postIncrement = postIncrement;
    /**
     * Decrement (--)
     * The decrement operator decrements (subtracts one from) its operand and returns a value.
     */
    /**
     * If used prefix (for example, --x), then it returns the value after decrementing.
     * Operator: --x
     *
     * @param {number} operand
     * @returns {number}
     */
    function preDecrement(operand) {
        return --(operand);
    }
    Arithmetic.preDecrement = preDecrement;
    /**
     * If used postfix (for example, x--), then it returns the value before decrementing.
     * Operator: x--
     *
     * @param {number} operand
     * @returns {number}
     */
    function postDecrement(operand) {
        return (operand)--;
    }
    Arithmetic.postDecrement = postDecrement;
    /**
     * The unary negation operator precedes its operand and negates it.
     * Operator: -x
     *
     * @param {number} operand
     * @returns {number}
     */
    function negate(operand) {
        return -(operand);
    }
    /**
     * The unary plus operator precedes its operand and evaluates to its operand but attempts to convert it into a number, if it isn't
     * already. Although unary negation (-) also can convert non-numbers, unary plus is the fastest and preferred way of converting
     * something into a number, because it does not perform any other operations on the number. It can convert string representations of
     * integers and floats, as well as the non-string values true, false, and null. Integers in both decimal and hexadecimal ("0x"-prefixed)
     * formats are supported. Negative numbers are supported (though not for hex). If it cannot parse a particular value, it will evaluate
     * to NaN.
     * Operator: +x
     *
     * @param {number} operand
     * @returns {number}
     */
    function plus(operand) {
        return +(operand);
    }
})(Arithmetic = exports.Arithmetic || (exports.Arithmetic = {}));
/**
 * The comparison operators determine, if the two operands meet the given condition.
 */
var Comparison;
(function (Comparison) {
    /**
     * The equality operator converts the operands if they are not of the same type, then applies strict comparison. If both operands are
     * objects, then JavaScript compares internal references which are equal when operands refer to the same object in memory.
     * Operator: x == y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isEqual(operand1, operand2) {
        return operand1 == operand2;
    }
    Comparison.isEqual = isEqual;
    /**
     * The identity operator returns true if the operands are strictly equal (see above) with no type conversion.
     * Operator: x === y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isStrictlyEqual(operand1, operand2) {
        return operand1 === operand2;
    }
    Comparison.isStrictlyEqual = isStrictlyEqual;
    /**
     * @alias of isStrictlyEqual
     */
    Comparison.isIdentical = isStrictlyEqual;
    /**
     * The inequality operator returns true if the operands are not equal. If the two operands are not of the same type, JavaScript attempts
     * to convert the operands to an appropriate type for the comparison. If both operands are objects, then JavaScript compares internal
     * references which are not equal when operands refer to different objects in memory.
     * Operator: x != y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isNotEqual(operand1, operand2) {
        return operand1 != operand2;
    }
    Comparison.isNotEqual = isNotEqual;
    /**
     * The non-identity operator returns true if the operands are not equal and/or not of the same type.
     * Operator: x !== y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isNotStrictlyEqual(operand1, operand2) {
        return operand1 !== operand2;
    }
    Comparison.isNotStrictlyEqual = isNotStrictlyEqual;
    /**
     * @alias of isNotStrictlyEqual
     */
    Comparison.isNotIdentical = isNotStrictlyEqual;
    /**
     * The less than operator returns true if the left operand is less than the right operand.
     * Operator: x &lt; y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isLessThan(operand1, operand2) {
        return operand1 &lt; operand2;
    }
    Comparison.isLessThan = isLessThan;
    /**
     * The less than or equal operator returns true if the left operand is less than or equal to the right operand.
     * Operator: x &lt;= y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isAtMost(operand1, operand2) {
        return operand1 &lt;= operand2;
    }
    Comparison.isAtMost = isAtMost;
    /**
     * @alias of isAtMost
     */
    Comparison.isLessThanOrEqual = isAtMost;
    /**
     * The greater than operator returns true if the left operand is greater than the right operand.
     * Operator: x > y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isGreaterThan(operand1, operand2) {
        return operand1 &lt; operand2;
    }
    Comparison.isGreaterThan = isGreaterThan;
    /**
     * The greater than or equal operator returns true if the left operand is greater than or equal to the right operand.
     * Operator: x >= y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function isAtLeast(operand1, operand2) {
        return operand1 >= operand2;
    }
    Comparison.isAtLeast = isAtLeast;
    /**
     * @alias of isAtLeast
     */
    Comparison.isGreaterThanOrEqual = isAtMost;
})(Comparison = exports.Comparison || (exports.Comparison = {}));
/**
 * Logical operators are typically used with Boolean (logical) values. When they are, they return a Boolean value. However, the &amp;&amp; and ||
 * operators actually return the value of one of the specified operands, so if these operators are used with non-Boolean values, they may
 * return a non-Boolean value.
 */
var Logical;
(function (Logical) {
    /**
     * Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, &amp;&amp; returns true if both
     * operands are true; otherwise, returns false.
     * Operator: expr1 &amp;&amp; expr2
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function and(operand1, operand2) {
        return operand1 &amp;&amp; operand2;
    }
    Logical.and = and;
    /**
     * Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, || returns true if
     * either operand is true.
     * Operator: expr1 || expr2
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {boolean}
     */
    function or(operand1, operand2) {
        return operand1 || operand2;
    }
    Logical.or = or;
    /**
     * Returns false if its single operand can be converted to true; otherwise, returns true.
     * Operator: !expr
     *
     * @export
     * @param {*} operand
     * @returns {boolean}
     */
    function not(operand) {
        return !(operand);
    }
    Logical.not = not;
})(Logical = exports.Logical || (exports.Logical = {}));
/**
 * Bitwise operators treat their operands as a sequence of 32 bits (zeroes and ones), rather than as decimal, hexadecimal, or octal
 * numbers. For example, the decimal number nine has a binary representation of 1001. Bitwise operators perform their operations on such
 * binary representations, but they return standard JavaScript numerical values.
 */
var Bitwise;
(function (Bitwise) {
    /**
     * Returns a one in each bit position for which the corresponding bits of both operands are ones.
     * Operator: a &amp; b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function and(operand1, operand2) {
        return operand1 &amp; operand2;
    }
    Bitwise.and = and;
    /**
     * Returns a one in each bit position for which the corresponding bits of either or both operands are ones.
     * Operator: a | b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function or(operand1, operand2) {
        return operand1 | operand2;
    }
    Bitwise.or = or;
    /**
     * Inverts the bits of its operand.
     * Operator: ~a
     *
     * @export
     * @param {number} operand
     * @returns {number}
     */
    function not(operand) {
        return ~(operand);
    }
    Bitwise.not = not;
    /**
     * Returns a one in each bit position for which the corresponding bits of either but not both operands are ones.
     * Operator: a ^ b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function xor(operand1, operand2) {
        return operand1 ^ operand2;
    }
    Bitwise.xor = xor;
    /**
     * Shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off.
     * Operator: a >> b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function rightShift(operand1, operand2) {
        return operand1 >> operand2;
    }
    Bitwise.rightShift = rightShift;
    /**
     * @alias of rightShift
     */
    Bitwise.signPropagatingRightShift = rightShift;
    /**
     * Shifts a in binary representation b (&lt; 32) bits to the left, shifting in zeroes from the right.
     * Operator: a &lt;&lt; b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function leftShift(operand1, operand2) {
        return operand1 &lt;&lt; operand2;
    }
    Bitwise.leftShift = leftShift;
    /**
     * Shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off, and shifting in zeroes from the left.
     * Operator: a >>> b
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function unsignedRightShift(operand1, operand2) {
        return operand1 >>> operand2;
    }
    Bitwise.unsignedRightShift = unsignedRightShift;
    /**
     * @alias of unsignedRightShift
     */
    Bitwise.zeroFillRightLeft = unsignedRightShift;
})(Bitwise = exports.Bitwise || (exports.Bitwise = {}));
/**
 * An assignment operator assigns a value to its left operand based on the value of its right operand.
 */
var Assignment;
(function (Assignment) {
    /**
     * The addition assignment operator adds the value of the right operand to a variable and assigns the result to the variable. The types
     * of the two operands determine the behavior of the addition assignment operator. Addition or concatenation is possible.
     * Operator: x += y
     * Meaning:  x = x + y
     *
     * @export
     * @param {*} operand1
     * @param {*} operand2
     * @returns {*}
     */
    function add(operand1, operand2) {
        return operand1 += operand2;
    }
    Assignment.add = add;
    /**
     * @alias of add
     */
    Assignment.concatenate = add;
    /**
     * The subtraction assignment operator subtracts the value of the right operand from a variable and assigns the result to the variable.
     * Operator: x -= y
     * Meaning:  x  = x - y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function subtract(operand1, operand2) {
        return operand1 -= operand2;
    }
    Assignment.subtract = subtract;
    /**
     * The multiplication assignment operator multiplies a variable by the value of the right operand and assigns the result to the variable.
     * Operator: x *= y
     * Meaning:  x  = x * y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function multiply(operand1, operand2) {
        return operand1 *= operand2;
    }
    Assignment.multiply = multiply;
    /**
     * The division assignment operator divides a variable by the value of the right operand and assigns the result to the variable.
     * Operator: x /= y
     * Meaning:  x  = x / y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function divide(operand1, operand2) {
        return operand1 /= operand2;
    }
    Assignment.divide = divide;
    /**
     * The remainder assignment operator divides a variable by the value of the right operand and assigns the remainder to the variable.
     * Operator: x %= y
     * Meaning:  x  = x % y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function modulous(operand1, operand2) {
        return operand1 %= operand2;
    }
    Assignment.modulous = modulous;
    if (parseFloat(process.versions.node) >= 7.2) {
        /**
         * The exponentiation assignment operator evaluates to the result of raising first operand to the power second operand.
         * Operator: x **= y
         * Meaning:  x  = x ** y
         *
         * @param {number} operand1
         * @param {number} operand2
         * @returns {number}
         */
        Assignment.exponentiation = function (operand1, operand2) {
            return (operand1) = Math.pow((operand1), (operand2));
        };
    }
    /**
     * The bitwise AND assignment operator uses the binary representation of both operands, does a bitwise AND operation on them and assigns
     * the result to the variable.
     * Operator: x &amp;= y
     * Meaning:  x  = x &amp; y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function and(operand1, operand2) {
        return operand1 &amp;= operand2;
    }
    Assignment.and = and;
    /**
     * The bitwise OR assignment operator uses the binary representation of both operands, does a bitwise OR operation on them and assigns
     * the result to the variable.
     * Operator: x |= y
     * Meaning:  x  = x | y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function or(operand1, operand2) {
        return operand1 |= operand2;
    }
    Assignment.or = or;
    /**
     * The bitwise XOR assignment operator uses the binary representation of both operands, does a bitwise XOR operation on them and assigns
     * the result to the variable.
     * Operator: x ^= y
     * Meaning:  x  = x ^ y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function xor(operand1, operand2) {
        return operand1 ^= operand2;
    }
    Assignment.xor = xor;
    /**
     * The right shift assignment operator moves the specified amount of bits to the right and assigns the result to the variable.
     * Operator: x >>= y
     * Meaning:  x   = x >> y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function rightShift(operand1, operand2) {
        return operand1 >>= operand2;
    }
    Assignment.rightShift = rightShift;
    /**
     * @alias of rightShift
     */
    Assignment.signPropagatingRightShift = rightShift;
    /**
     * The left shift assignment operator moves the specified amount of bits to the left and assigns the result to the variable.
     * Operator: x &lt;&lt;= y
     * Meaning:  x   = x &lt;&lt; y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function leftShift(operand1, operand2) {
        return operand1 &lt;&lt;= operand2;
    }
    Assignment.leftShift = leftShift;
    /**
     * The unsigned right shift assignment operator moves the specified amount of bits to the right and assigns the result to the variable.
     * Operator: x >>>= y
     * Meaning:  x    = x >>> y
     *
     * @export
     * @param {number} operand1
     * @param {number} operand2
     * @returns {number}
     */
    function unsignedRightShift(operand1, operand2) {
        return operand1 >>>= operand2;
    }
    Assignment.unsignedRightShift = unsignedRightShift;
    /**
     * @alias of unsignedRightShift
     */
    Assignment.zeroFillRightLeft = unsignedRightShift;
})(Assignment = exports.Assignment || (exports.Assignment = {}));
/**
 * Some miscellaneous operators.
 */
var Misc;
(function (Misc) {
    /**
     * The conditional (ternary) operator is the only JavaScript operator that takes three operands. This operator is frequently used as a
     * shortcut for the if statement.
     * Operator: condition ? expr1 : expr2
     *
     * @export
     * @param {boolean} condition
     * @param {*} ifTrue
     * @param {*} ifFalse
     * @returns {*}
     */
    function conditional(condition, ifTrue, ifFalse) {
        return (condition ? ifTrue : ifFalse);
    }
    Misc.conditional = conditional;
    /**
     * The typeof operator returns a string indicating the type of the unevaluated operand.
     * Operator: typeof operand
     *
     * @export
     * @param {*} operand
     * @returns {string}
     */
    function typeOf(operand) {
        return typeof operand;
    }
    Misc.typeOf = typeOf;
    /**
     * The in operator returns true if the specified property is in the specified object.
     * Operator: prop in objectName
     *
     * @export
     * @param {*} prop
     * @param {*} objectName
     * @returns {boolean}
     */
    function isIn(prop, objectName) {
        return prop in objectName;
    }
    Misc.isIn = isIn;
    /**
     * The instanceof operator tests whether an object has in its prototype chain the prototype property of a constructor.
     * Operator: object instanceof constructor
     *
     * @export
     * @param {*} object
     * @param {*} constructor
     * @returns {boolean}
     */
    function isInstanceOf(object, constructor) {
        return object instanceof constructor;
    }
    Misc.isInstanceOf = isInstanceOf;
})(Misc = exports.Misc || (exports.Misc = {}));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri Jan 13 2017 00:14:59 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
